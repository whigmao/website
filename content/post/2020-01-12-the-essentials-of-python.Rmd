---
title: The Essentials of Python
author: Guanghua Mao
date: '2020-01-12'
slug: the-essentials-of-python
categories:
  - Python
tags:
  - Python
  - Programming
  - Mac
---

# 1. About Python 3

Python is a modern, object-oriented scripting language. There's a core philosophy behind the Python language, which includes the following statements: Beautiful is better than ugly. It's always a good idea to make your code elegant and readable. Explicit is better than implicit. Don't make your readers guess what your code does, make it obvious. Simple is better than complex. If you can make it simple, do. Complex is better than complicated. If complexity is necessary, don't complicate it. Readability counts. ython is a rich language, and it would be impossible for me to cover all of it. [The online documentation](https://docs.python.org/3/) is both accessible and exhaustive. I recommend you become familiar with it. Python is a very powerful and versatile programming language, and is easy to learn.


---

# 2. Overview

Python does not look like a lot of other languages. It doesn't use braces or semicolons, **line endings and indentation** are meaningful, and in Python, everything is an object. Before we delve into the details of language features, it can be useful to see how all the pieces fit together. 

```{python Hello World}
print('Hello World!')
```

The *Hello World program* is a traditional first step in learning a new language, but it's actually more than that. The purpose of Hello World is to validate your development environment. Whenever you set up a new development environment, it's a good idea to use a simple, minimal, and functional program to confirm that your development cycle functions as you expect, and that's what Hello World is for.

If you want to know the fundamentals of programming and basic elements of Python, you can read [the article](https://guanghuamao.netlify.com/2020/01/09/the-fundamentals-of-programming/) I wrote before.



---


---

# 3. Types and Values
 
There are just a few fundamental data types in Python. Python uses a form of dynamic typing sometimes called duck typing where the type of a value is determined by the value itself. In other words, if it walks like a duck, it's a duck. I will show you what that means in the following scripts.

```{python Data Types}
x = 7

y = 7.0

z = "7.0"

#type is the built-in function
print(type(x),type(y), type(z))

```


## 3.1 String Objects
I'll go into much more detail about string objects in a later chapter, but for now it's good to understand a few common patterns. In Python, there is no difference between single quotes and double quotes.

```{python string 1}
x = 'seven'

y = "seven"

z = '''

seven

'''

print(x)

print(y)

print(z)

```

You can use three single quotes. And if I save and run you'll see there's no difference. What that allows you to do, though, is to put things on several lines. So, using three quotes you can actually make a multi-line string.

Now, as I mentioned, strings are objects, even literal strings. So, here I have a literal string, the seven in quotes, and it's an object, so I can run methods on that object. 
```{python run methods on string}
# Capitalize the string
x = 'seven'.capitalize()

print(x)

# Uppercase
y = 'seven'.upper()

print(y)

#lowercase

z = 'seven'.lower()

print(z)

```

In fact, I can even put some placemarkers in it and use format.

```{python placemarkers}
#use placemarker
x = 'seven {} {}'.format(8,9)

print(x)

#change the place
y = 'seven {1} {0}'.format(8,9)

print(y)

#another way to format
a = 8

b = 9

z = f'seven {a:<09} {b:>9}'

print(z)

```

## 3.2 Numeric Types

Python 3 has two basic numeric types, integer and floating point. There are other types derived from these including the built in complex type. In fact, because everything is an object in Python, you can derive your own types. Here we're going to talk about integer and float.

```{python numric}
x = 7 

y = 2.0

print(type(x),type(y))

```


Here's an interesting problem. If I say point one, plus point one, plus point one, minus point three, you would expect my result would be zero, but it is not.

```{python}
x = 0.1 + 0.1 + 0.1 -0.3

print(x)
```


This is the difference between **accuracy and precision**. Because of the way that the computers do floating point, they're sacrificing accuracy for precision and so it may do this arithmetic correctly to 17 decimal places, which is the precision of the floating point processor inside the computer. But it is not accurate. Accuracy is the true value of a calculation.

So how do we solve this problem?

```{python}
from decimal import *

a = Decimal('.10')

b = Decimal('.30')

x = a + a + a - b

print(x)
```


Understanding the numeric types can save you a great deal of trouble for many purposes.

## 3.3 The bool Type

The bool type is used for logical values and expressions. The bool type is used for logical values and expressions. None evaluates as false, zero evaluates as false, and an empty string evaluates as false.

```{python bool type}
x = True

y = False

print(type(x))

print(type(y))

```

## 3.4 Sequence Types

Python provides some built-in sequence types, including **lists, tuples, and dictionaries**. 

A **list** is created with square brackets. A list is a mutable sequence, so I can reassign one of the values after I have assigned it. 

```{python list}
x = [1,2,3]

print(x,type(x))

# list starts with zero
x[0] = 4

print(x)

```


On the other hand, a **tuple** is exactly like a list, only it's immutable, and it's indicated by parentheses.

```{python tuple}
x = (1,2,3)

print(x,type(x))

```


I'll tend to use the parentheses by default, and only use the square brackets when I know that I need to change something. 

You can also create a sequence using **range**. There's actually three possible parameters for range. They're start, end, and step, and if you specify a just two, it start and end, and if you specify just one, it's just end. If I want a mutable list, I simply construct a list with the results from range using the list constructor.

```{python range}

x = range(3,10,2)

print(type(x))

for i in x:
  print(i)

```


A **dictionary** is a searchable sequence of key value pairs. Each of these values, the keys and the values can be any type, and the same is true for lists and tuples, any element can be any type. And dictionaries are mutable.

```{python dictionary}
x = {"a":1, "b":2, "c":3}

print(x,type(x))

# dictionary is mutable

x["a"] = 4

print(x)

```


These built-in sequence types are very useful, and flexible.

---

# 4. Conditionals

## 4.1 Conditional Syntax

The Python syntax for conditional statements is consistent with the rest of the language. The conditional statement in Python is simple and easy. It uses the familiar if, else, elif keywords, and the typical Python indented block syntax.

```{python conditional syntax}

x = 5

# conditional syntax

if x == 0:
  print('0 true')
elif x == 1:
  print('1 true')
elif x == 2:
  print('2 true')
elif x == 5:
  print('5 ture')
else:
  print('none true')

```

## 4.2 Conditional Operators


|Comparison Operators | Logical Operators | Identity Operators |
--------------------  | ----------------- |------------------- |
|== | and | x is y     |
|!= | or  | x is not y |
|<  | not |
|>  |
|<= |
|>= |

----

# 5. Operators

| Arithmetic Operators | Bitwise Operators | Comparison Operators | Boolean Operators |
| -------------------- | ----------------- | -------------------- | ----------------- |
| + Addition           | & And             | ==                   | and
| - Subtraction        | | Or              | !=                   | or
| * Multiplocation     | ^ Xor             | <=                   | not
| / Division           | << Shift left     | >=                   | in
| // Integer Devision  | >> Shift right    | >                    | not in
| % Remainder          |                   | <                    | is
| ** Exponent          |                   |                      | is not
| - Unary negative
| + Unary positive

---

# 6. Loops

## 6.1 Loops Introduction

Python has two basic forms of loops, **while loops and for loops**. 

A while loop uses a conditional expression to control the loop. When the condition is true, the body of the loop is executed. When the body is complete, the condition is tested again. And if the condition is still true, the body is executed again. The loop continues as long as the condition is true, and when the condition is false, the loop ends and execution continues with the lines of code after the loop. 

![While Loop](/post/2020-01-12-the-essentials-of-python_files/while loop.png)

```{python while loop}
a = 5

b = 2

while b < a:
  b = 2 * b
else:
  print(b)

```


A for loop uses a sequence, like an iterator or a list, tuple, or other collection type to control the loop. The body of the loop is executed for each item in the sequence, and when the sequence is exhausted the loop ends.

![For Loop](/post/2020-01-12-the-essentials-of-python_files/for loop.png)

```{python for loop}

x = [1,2,3,4]

for i in x:
  print("i  is {}".format(i))
```

## 6.2 Additional Loop Controls

![Additional Loop Controls](/post/2020-01-12-the-essentials-of-python_files/Additional Loop Controls.png)

Both the while and for loops have some additional controls that are worth understanding. Three additional controls are available continue, break, and else. The continue clause is used to shortcut a loop and start it again as if it had reached the end of its body of code. The break clause is used to break out of a loop prematurely, execution will continue after the entire loop structure and the else control is not common in other languages so you may not have seen this before. The else block executes only if the loop ends normally. It will not execute if a break is used to end the loop. These same controls are available for both while and for loops.


---

# 7. Functions

If you want to know the basic syntax of function of Python, you can read [the article](https://guanghuamao.netlify.com/2020/01/09/the-fundamentals-of-programming/) I wrote before.
```{python argument lists}
def main():
  kitten('one','two','three')

def kitten(*args):
  if len(args):
    for s in args:
      print(s)
  else: 
    print('None')
  
main()

```

A **generator** is a special class of function that serves as an iterator instead of returning a single value the generator returns a stream of values.

A **decorator** is a form of metaprogramming and it can be described as a special type of function that returns a wrapper function. 

```{python decotator}

def f1(f):
  def f2():
    print('before')
    f()
    print('after')
  return f2

@f1 # this is decorator
def f3():
  print('f3')
  
f3()

```


# 8. Classes

A class is the basis of all data in Python, everything is an object in Python, and a class is how an object is defined.

You may need to understand object-oriented programming first.

---

# 9. String Objects

## 9.1 Formatting

I mentioned how to format string object before, so I will not repeat it here.

## 9.2 Splitting and Joining

Python allows you to easily split and join strings based on separator characters.

```{python spliting and joining}

x = 'How to split and join a string'

print(x.split())

print(x.split('o'))

y = x.split()

z = '--'.join(y)

print(z)

```

---


In this article, my goal was to provide you with the basic knowledge you'll need to write good, effective Python scripts. I've shown you the fundamentals and basic syntax of a typical Python script so you can be well prepared to construct your own scripts. How types and values work with python's rich object system, how to construct conditionals and loops and how to use functions, generators and decorators. I've hope you've enjoyed this article as much as I've enjoyed creating it for you. So have fun, and create something wonderful with your own Python scripts.






















































